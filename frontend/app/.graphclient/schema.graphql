schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

type BorrowerInfo {
  id: ID!
  troves: Int!
  trovesByCollateral: [Int!]!
}

input BorrowerInfo_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  troves: Int
  troves_not: Int
  troves_gt: Int
  troves_lt: Int
  troves_gte: Int
  troves_lte: Int
  troves_in: [Int!]
  troves_not_in: [Int!]
  trovesByCollateral: [Int!]
  trovesByCollateral_not: [Int!]
  trovesByCollateral_contains: [Int!]
  trovesByCollateral_contains_nocase: [Int!]
  trovesByCollateral_not_contains: [Int!]
  trovesByCollateral_not_contains_nocase: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [BorrowerInfo_filter]
  or: [BorrowerInfo_filter]
}

enum BorrowerInfo_orderBy {
  id
  troves
  trovesByCollateral
}

scalar Bytes

type Collateral {
  id: ID!
  collIndex: Int!
  token: Token!
  minCollRatio: BigInt!
  troves(skip: Int = 0, first: Int = 100, orderBy: Trove_orderBy, orderDirection: OrderDirection, where: Trove_filter): [Trove!]!
  addresses: CollateralAddresses!
  stabilityPoolDeposits(skip: Int = 0, first: Int = 100, orderBy: StabilityPoolDeposit_orderBy, orderDirection: OrderDirection, where: StabilityPoolDeposit_filter): [StabilityPoolDeposit!]!
  totalDeposited: BigInt!
  totalDebt: BigInt!
  price: BigInt!
}

type CollateralAddresses {
  id: ID!
  borrowerOperations: Bytes!
  collateral: Collateral!
  sortedTroves: Bytes!
  stabilityPool: Bytes!
  token: Bytes!
  troveManager: Bytes!
  troveNft: Bytes!
}

input CollateralAddresses_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  borrowerOperations: Bytes
  borrowerOperations_not: Bytes
  borrowerOperations_gt: Bytes
  borrowerOperations_lt: Bytes
  borrowerOperations_gte: Bytes
  borrowerOperations_lte: Bytes
  borrowerOperations_in: [Bytes!]
  borrowerOperations_not_in: [Bytes!]
  borrowerOperations_contains: Bytes
  borrowerOperations_not_contains: Bytes
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: Collateral_filter
  sortedTroves: Bytes
  sortedTroves_not: Bytes
  sortedTroves_gt: Bytes
  sortedTroves_lt: Bytes
  sortedTroves_gte: Bytes
  sortedTroves_lte: Bytes
  sortedTroves_in: [Bytes!]
  sortedTroves_not_in: [Bytes!]
  sortedTroves_contains: Bytes
  sortedTroves_not_contains: Bytes
  stabilityPool: Bytes
  stabilityPool_not: Bytes
  stabilityPool_gt: Bytes
  stabilityPool_lt: Bytes
  stabilityPool_gte: Bytes
  stabilityPool_lte: Bytes
  stabilityPool_in: [Bytes!]
  stabilityPool_not_in: [Bytes!]
  stabilityPool_contains: Bytes
  stabilityPool_not_contains: Bytes
  token: Bytes
  token_not: Bytes
  token_gt: Bytes
  token_lt: Bytes
  token_gte: Bytes
  token_lte: Bytes
  token_in: [Bytes!]
  token_not_in: [Bytes!]
  token_contains: Bytes
  token_not_contains: Bytes
  troveManager: Bytes
  troveManager_not: Bytes
  troveManager_gt: Bytes
  troveManager_lt: Bytes
  troveManager_gte: Bytes
  troveManager_lte: Bytes
  troveManager_in: [Bytes!]
  troveManager_not_in: [Bytes!]
  troveManager_contains: Bytes
  troveManager_not_contains: Bytes
  troveNft: Bytes
  troveNft_not: Bytes
  troveNft_gt: Bytes
  troveNft_lt: Bytes
  troveNft_gte: Bytes
  troveNft_lte: Bytes
  troveNft_in: [Bytes!]
  troveNft_not_in: [Bytes!]
  troveNft_contains: Bytes
  troveNft_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CollateralAddresses_filter]
  or: [CollateralAddresses_filter]
}

enum CollateralAddresses_orderBy {
  id
  borrowerOperations
  collateral
  collateral__id
  collateral__collIndex
  collateral__minCollRatio
  collateral__totalDeposited
  collateral__totalDebt
  collateral__price
  sortedTroves
  stabilityPool
  token
  troveManager
  troveNft
}

input Collateral_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  collIndex: Int
  collIndex_not: Int
  collIndex_gt: Int
  collIndex_lt: Int
  collIndex_gte: Int
  collIndex_lte: Int
  collIndex_in: [Int!]
  collIndex_not_in: [Int!]
  token: String
  token_not: String
  token_gt: String
  token_lt: String
  token_gte: String
  token_lte: String
  token_in: [String!]
  token_not_in: [String!]
  token_contains: String
  token_contains_nocase: String
  token_not_contains: String
  token_not_contains_nocase: String
  token_starts_with: String
  token_starts_with_nocase: String
  token_not_starts_with: String
  token_not_starts_with_nocase: String
  token_ends_with: String
  token_ends_with_nocase: String
  token_not_ends_with: String
  token_not_ends_with_nocase: String
  token_: Token_filter
  minCollRatio: BigInt
  minCollRatio_not: BigInt
  minCollRatio_gt: BigInt
  minCollRatio_lt: BigInt
  minCollRatio_gte: BigInt
  minCollRatio_lte: BigInt
  minCollRatio_in: [BigInt!]
  minCollRatio_not_in: [BigInt!]
  troves_: Trove_filter
  addresses_: CollateralAddresses_filter
  stabilityPoolDeposits_: StabilityPoolDeposit_filter
  totalDeposited: BigInt
  totalDeposited_not: BigInt
  totalDeposited_gt: BigInt
  totalDeposited_lt: BigInt
  totalDeposited_gte: BigInt
  totalDeposited_lte: BigInt
  totalDeposited_in: [BigInt!]
  totalDeposited_not_in: [BigInt!]
  totalDebt: BigInt
  totalDebt_not: BigInt
  totalDebt_gt: BigInt
  totalDebt_lt: BigInt
  totalDebt_gte: BigInt
  totalDebt_lte: BigInt
  totalDebt_in: [BigInt!]
  totalDebt_not_in: [BigInt!]
  price: BigInt
  price_not: BigInt
  price_gt: BigInt
  price_lt: BigInt
  price_gte: BigInt
  price_lte: BigInt
  price_in: [BigInt!]
  price_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Collateral_filter]
  or: [Collateral_filter]
}

enum Collateral_orderBy {
  id
  collIndex
  token
  token__id
  token__name
  token__symbol
  token__decimals
  minCollRatio
  troves
  addresses
  addresses__id
  addresses__borrowerOperations
  addresses__sortedTroves
  addresses__stabilityPool
  addresses__token
  addresses__troveManager
  addresses__troveNft
  stabilityPoolDeposits
  totalDeposited
  totalDebt
  price
}

"""
8 bytes signed integer

"""
scalar Int8

type InterestRateBracket {
  id: ID!
  rate: BigInt!
  totalDebt: BigInt!
  totalTroves: Int!
}

input InterestRateBracket_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  rate: BigInt
  rate_not: BigInt
  rate_gt: BigInt
  rate_lt: BigInt
  rate_gte: BigInt
  rate_lte: BigInt
  rate_in: [BigInt!]
  rate_not_in: [BigInt!]
  totalDebt: BigInt
  totalDebt_not: BigInt
  totalDebt_gt: BigInt
  totalDebt_lt: BigInt
  totalDebt_gte: BigInt
  totalDebt_lte: BigInt
  totalDebt_in: [BigInt!]
  totalDebt_not_in: [BigInt!]
  totalTroves: Int
  totalTroves_not: Int
  totalTroves_gt: Int
  totalTroves_lt: Int
  totalTroves_gte: Int
  totalTroves_lte: Int
  totalTroves_in: [Int!]
  totalTroves_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [InterestRateBracket_filter]
  or: [InterestRateBracket_filter]
}

enum InterestRateBracket_orderBy {
  id
  rate
  totalDebt
  totalTroves
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Query {
  collateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collateral
  collaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: Collateral_orderBy
    orderDirection: OrderDirection
    where: Collateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collateral!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  collateralAddresses(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralAddresses
  collateralAddresses_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralAddresses_orderBy
    orderDirection: OrderDirection
    where: CollateralAddresses_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralAddresses!]!
  interestRateBracket(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InterestRateBracket
  interestRateBrackets(
    skip: Int = 0
    first: Int = 100
    orderBy: InterestRateBracket_orderBy
    orderDirection: OrderDirection
    where: InterestRateBracket_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [InterestRateBracket!]!
  trove(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trove
  troves(
    skip: Int = 0
    first: Int = 100
    orderBy: Trove_orderBy
    orderDirection: OrderDirection
    where: Trove_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trove!]!
  borrowerInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowerInfo
  borrowerInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: BorrowerInfo_orderBy
    orderDirection: OrderDirection
    where: BorrowerInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BorrowerInfo!]!
  stabilityPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityPool
  stabilityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: StabilityPool_orderBy
    orderDirection: OrderDirection
    where: StabilityPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StabilityPool!]!
  stabilityPoolDeposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityPoolDeposit
  stabilityPoolDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: StabilityPoolDeposit_orderBy
    orderDirection: OrderDirection
    where: StabilityPoolDeposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StabilityPoolDeposit!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type StabilityPool {
  id: ID!
  totalDeposited: BigInt!
}

type StabilityPoolDeposit {
  id: ID!
  boldGain: BigInt!
  collGain: BigInt!
  collateral: Collateral!
  deposit: BigInt!
  depositor: Bytes!
}

input StabilityPoolDeposit_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  boldGain: BigInt
  boldGain_not: BigInt
  boldGain_gt: BigInt
  boldGain_lt: BigInt
  boldGain_gte: BigInt
  boldGain_lte: BigInt
  boldGain_in: [BigInt!]
  boldGain_not_in: [BigInt!]
  collGain: BigInt
  collGain_not: BigInt
  collGain_gt: BigInt
  collGain_lt: BigInt
  collGain_gte: BigInt
  collGain_lte: BigInt
  collGain_in: [BigInt!]
  collGain_not_in: [BigInt!]
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: Collateral_filter
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  depositor: Bytes
  depositor_not: Bytes
  depositor_gt: Bytes
  depositor_lt: Bytes
  depositor_gte: Bytes
  depositor_lte: Bytes
  depositor_in: [Bytes!]
  depositor_not_in: [Bytes!]
  depositor_contains: Bytes
  depositor_not_contains: Bytes
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StabilityPoolDeposit_filter]
  or: [StabilityPoolDeposit_filter]
}

enum StabilityPoolDeposit_orderBy {
  id
  boldGain
  collGain
  collateral
  collateral__id
  collateral__collIndex
  collateral__minCollRatio
  collateral__totalDeposited
  collateral__totalDebt
  collateral__price
  deposit
  depositor
}

input StabilityPool_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  totalDeposited: BigInt
  totalDeposited_not: BigInt
  totalDeposited_gt: BigInt
  totalDeposited_lt: BigInt
  totalDeposited_gte: BigInt
  totalDeposited_lte: BigInt
  totalDeposited_in: [BigInt!]
  totalDeposited_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [StabilityPool_filter]
  or: [StabilityPool_filter]
}

enum StabilityPool_orderBy {
  id
  totalDeposited
}

type Subscription {
  collateral(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Collateral
  collaterals(
    skip: Int = 0
    first: Int = 100
    orderBy: Collateral_orderBy
    orderDirection: OrderDirection
    where: Collateral_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Collateral!]!
  token(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Token
  tokens(
    skip: Int = 0
    first: Int = 100
    orderBy: Token_orderBy
    orderDirection: OrderDirection
    where: Token_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Token!]!
  collateralAddresses(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CollateralAddresses
  collateralAddresses_collection(
    skip: Int = 0
    first: Int = 100
    orderBy: CollateralAddresses_orderBy
    orderDirection: OrderDirection
    where: CollateralAddresses_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CollateralAddresses!]!
  interestRateBracket(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): InterestRateBracket
  interestRateBrackets(
    skip: Int = 0
    first: Int = 100
    orderBy: InterestRateBracket_orderBy
    orderDirection: OrderDirection
    where: InterestRateBracket_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [InterestRateBracket!]!
  trove(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Trove
  troves(
    skip: Int = 0
    first: Int = 100
    orderBy: Trove_orderBy
    orderDirection: OrderDirection
    where: Trove_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Trove!]!
  borrowerInfo(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): BorrowerInfo
  borrowerInfos(
    skip: Int = 0
    first: Int = 100
    orderBy: BorrowerInfo_orderBy
    orderDirection: OrderDirection
    where: BorrowerInfo_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [BorrowerInfo!]!
  stabilityPool(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityPool
  stabilityPools(
    skip: Int = 0
    first: Int = 100
    orderBy: StabilityPool_orderBy
    orderDirection: OrderDirection
    where: StabilityPool_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StabilityPool!]!
  stabilityPoolDeposit(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): StabilityPoolDeposit
  stabilityPoolDeposits(
    skip: Int = 0
    first: Int = 100
    orderBy: StabilityPoolDeposit_orderBy
    orderDirection: OrderDirection
    where: StabilityPoolDeposit_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [StabilityPoolDeposit!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type Token {
  id: ID!
  collateral: Collateral!
  name: String!
  symbol: String!
  decimals: Int!
}

input Token_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: Collateral_filter
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  decimals: Int
  decimals_not: Int
  decimals_gt: Int
  decimals_lt: Int
  decimals_gte: Int
  decimals_lte: Int
  decimals_in: [Int!]
  decimals_not_in: [Int!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Token_filter]
  or: [Token_filter]
}

enum Token_orderBy {
  id
  collateral
  collateral__id
  collateral__collIndex
  collateral__minCollRatio
  collateral__totalDeposited
  collateral__totalDebt
  collateral__price
  name
  symbol
  decimals
}

type Trove {
  id: ID!
  troveId: String!
  borrower: Bytes!
  debt: BigInt!
  deposit: BigInt!
  stake: BigInt!
  interestRate: BigInt!
  createdAt: BigInt!
  closedAt: BigInt
  collateral: Collateral!
}

input Trove_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  troveId: String
  troveId_not: String
  troveId_gt: String
  troveId_lt: String
  troveId_gte: String
  troveId_lte: String
  troveId_in: [String!]
  troveId_not_in: [String!]
  troveId_contains: String
  troveId_contains_nocase: String
  troveId_not_contains: String
  troveId_not_contains_nocase: String
  troveId_starts_with: String
  troveId_starts_with_nocase: String
  troveId_not_starts_with: String
  troveId_not_starts_with_nocase: String
  troveId_ends_with: String
  troveId_ends_with_nocase: String
  troveId_not_ends_with: String
  troveId_not_ends_with_nocase: String
  borrower: Bytes
  borrower_not: Bytes
  borrower_gt: Bytes
  borrower_lt: Bytes
  borrower_gte: Bytes
  borrower_lte: Bytes
  borrower_in: [Bytes!]
  borrower_not_in: [Bytes!]
  borrower_contains: Bytes
  borrower_not_contains: Bytes
  debt: BigInt
  debt_not: BigInt
  debt_gt: BigInt
  debt_lt: BigInt
  debt_gte: BigInt
  debt_lte: BigInt
  debt_in: [BigInt!]
  debt_not_in: [BigInt!]
  deposit: BigInt
  deposit_not: BigInt
  deposit_gt: BigInt
  deposit_lt: BigInt
  deposit_gte: BigInt
  deposit_lte: BigInt
  deposit_in: [BigInt!]
  deposit_not_in: [BigInt!]
  stake: BigInt
  stake_not: BigInt
  stake_gt: BigInt
  stake_lt: BigInt
  stake_gte: BigInt
  stake_lte: BigInt
  stake_in: [BigInt!]
  stake_not_in: [BigInt!]
  interestRate: BigInt
  interestRate_not: BigInt
  interestRate_gt: BigInt
  interestRate_lt: BigInt
  interestRate_gte: BigInt
  interestRate_lte: BigInt
  interestRate_in: [BigInt!]
  interestRate_not_in: [BigInt!]
  createdAt: BigInt
  createdAt_not: BigInt
  createdAt_gt: BigInt
  createdAt_lt: BigInt
  createdAt_gte: BigInt
  createdAt_lte: BigInt
  createdAt_in: [BigInt!]
  createdAt_not_in: [BigInt!]
  closedAt: BigInt
  closedAt_not: BigInt
  closedAt_gt: BigInt
  closedAt_lt: BigInt
  closedAt_gte: BigInt
  closedAt_lte: BigInt
  closedAt_in: [BigInt!]
  closedAt_not_in: [BigInt!]
  collateral: String
  collateral_not: String
  collateral_gt: String
  collateral_lt: String
  collateral_gte: String
  collateral_lte: String
  collateral_in: [String!]
  collateral_not_in: [String!]
  collateral_contains: String
  collateral_contains_nocase: String
  collateral_not_contains: String
  collateral_not_contains_nocase: String
  collateral_starts_with: String
  collateral_starts_with_nocase: String
  collateral_not_starts_with: String
  collateral_not_starts_with_nocase: String
  collateral_ends_with: String
  collateral_ends_with_nocase: String
  collateral_not_ends_with: String
  collateral_not_ends_with_nocase: String
  collateral_: Collateral_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [Trove_filter]
  or: [Trove_filter]
}

enum Trove_orderBy {
  id
  troveId
  borrower
  debt
  deposit
  stake
  interestRate
  createdAt
  closedAt
  collateral
  collateral__id
  collateral__collIndex
  collateral__minCollRatio
  collateral__totalDeposited
  collateral__totalDebt
  collateral__price
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}